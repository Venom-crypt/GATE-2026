# Theory of Computation Complete Study Guide - GATE 2026

## Part 1: Regular Expressions and Finite Automata

### 1.1 Regular Expressions (Regex)

**Definition:** Patterns that describe regular languages using operators and symbols.

**Basic Operators:**
- **Concatenation:** AB (A followed by B)
- **Alternation:** A|B (A or B)
- **Kleene Star:** A* (0 or more occurrences of A)
- **Plus:** A+ (1 or more occurrences of A)
- **Question mark:** A? (0 or 1 occurrence of A)

**Examples:**
```
(a|b)* = Any string of a's and b's
a*b* = Zero or more a's followed by zero or more b's
(ab)+ = One or more occurrences of "ab"
0(1|0)*1 = Strings starting with 0, ending with 1
```

### 1.2 Finite Automata

**DFA (Deterministic Finite Automaton):**
- Each state has exactly one transition for each symbol
- No epsilon (ε) transitions
- Deterministic: Given state and symbol, next state is unique
- **Definition:** (Q, Σ, δ, q0, F) where:
  - Q: Set of states
  - Σ: Alphabet
  - δ: Transition function
  - q0: Start state
  - F: Final states

**NFA (Non-Deterministic Finite Automaton):**
- Can have multiple transitions for same symbol
- Can have epsilon (ε) transitions
- Multiple paths possible
- Same definition as DFA, but δ returns set of states

**Key Difference:**
- **DFA:** δ(q, a) = q' (single state)
- **NFA:** δ(q, a) = {q1, q2, ...} (set of states)

### 1.3 Equivalence of DFA and NFA

**Theorem:** For every NFA, there exists equivalent DFA.

**Conversion Methods:**
1. **Subset Construction:** Each state in DFA corresponds to subset of NFA states
2. **Power Set Construction:** Maximum 2^n states in DFA for n NFA states

**Algorithm:**
```
1. Start: q0_DFA = ε-closure({q0_NFA})
2. For each state in DFA and each symbol:
   - Compute next state as ε-closure of all NFA states reachable
3. Final states in DFA: States containing any NFA final state
```

### 1.4 Regular Expressions to Finite Automata

**Construction:** Convert regex → NFA → DFA (optional)

**Thompson's Construction:** Convert regex to NFA
- Atomic: Symbol 'a' has single transition
- Concatenation: Combine NFAs sequentially
- Alternation: Epsilon transitions to both NFAs
- Star: Epsilon loop back

### 1.5 DFA to Regular Expression

**Arden's Method:**

For each state equation: q = q·A + q'·B + ... + ε

Use Arden's theorem: If Q = Q·R + P and ε ∉ L(R), then Q = P·R*

**Steps:**
1. Form equations for each state
2. Add ε to equation of initial state
3. Bring final state to form: Qf = Q·R + P
4. Apply Arden's theorem repeatedly
5. Result: Regular expression for the DFA

---

## Part 2: Context-Free Grammars and Pushdown Automata

### 2.1 Context-Free Grammar (CFG)

**Definition:** G = (V, T, P, S) where:
- V: Set of variables (non-terminals)
- T: Set of terminals
- P: Set of productions A → α
- S: Start variable

**Production Form:** A → α where A ∈ V, α ∈ (V ∪ T)*

**Example:**
```
S → aSb | ε
Generates: {a^n b^n | n ≥ 0}
```

### 2.2 Derivation and Language

**Leftmost Derivation:** Always expand leftmost non-terminal
**Rightmost Derivation:** Always expand rightmost non-terminal

**Language Generated:** L(G) = {w ∈ T* | S ⟹* w}

### 2.3 Parse Trees

Hierarchical representation of derivation.

**Root:** Start symbol
**Leaves:** Terminals (string)
**Internal nodes:** Variables with productions as rules

### 2.4 Ambiguity

**Ambiguous Grammar:** Multiple parse trees for same string

**Example:**
```
E → E + E | E * E | id

String: 2 + 3 * 4
Can be: (2+3)*4 or 2+(3*4)  [Ambiguous!]
```

**Resolution:** Add precedence and associativity

### 2.5 Pushdown Automaton (PDA)

**Definition:** (Q, Σ, Γ, δ, q0, Z0, F) where:
- Q: States
- Σ: Input alphabet
- Γ: Stack alphabet
- δ: Transition function
- q0: Start state
- Z0: Initial stack symbol
- F: Final states

**Transition:** δ(q, a, X) = (q', Y₁Y₂...Yk)
- Read: a from input
- Pop: X from stack
- Push: Y₁Y₂...Yk onto stack
- Move: from q to q'

**Acceptance:**
1. **By final state:** Input consumed, in final state
2. **By empty stack:** Input consumed, stack empty

### 2.6 CFG to PDA Conversion

**Construction:** For each production, create transitions

**Standard Method:**
1. Initial: Push $ and start symbol
2. For production A → α: Pop A, push α in reverse
3. For terminal a: Pop a, match with input a
4. Final: Pop $, accept

---

## Part 3: Regular and Context-Free Languages

### 3.1 Regular Languages

**Definition:** Languages accepted by DFA/NFA or generated by regular expression

**Closure Properties:** Regular languages closed under:
- Union
- Intersection
- Complement
- Concatenation
- Kleene star
- Reversal

**Decision Properties:**
- **Membership:** Is w in L? (Decidable)
- **Emptiness:** Is L empty? (Decidable)
- **Finiteness:** Is L finite? (Decidable)
- **Equivalence:** Are L1 and L2 same? (Decidable)

### 3.2 Context-Free Languages

**Definition:** Languages generated by CFG or accepted by PDA

**Closure Properties:** CFL closed under:
- Union
- Concatenation
- Kleene star
- Reversal

**NOT closed under:**
- Intersection
- Complement
- Negation

**Decision Properties:**
- **Membership:** Is w in L? (Decidable)
- **Emptiness:** Is L empty? (Decidable)
- **Finiteness:** Is L finite? (Decidable)

### 3.3 Relationship Between Language Classes

```
Regular Languages ⊂ Context-Free Languages ⊂ Recursive Languages ⊂ Recursively Enumerable
```

---

## Part 4: Pumping Lemma

### 4.1 Pumping Lemma for Regular Languages

**Statement:** If L is regular, then ∃ p (pumping length) such that:
- For all w ∈ L with |w| ≥ p
- w = xyz where |xy| ≤ p and |y| > 0
- For all i ≥ 0: xy^i z ∈ L

**Proof Concept:** By pigeonhole principle, DFA with p states must repeat state within p transitions.

**Use:** Prove language is NON-REGULAR by contradiction

**Steps to Prove L Not Regular:**
1. Assume L is regular with pumping length p
2. Choose string w ∈ L with |w| ≥ p
3. Consider all possible splits w = xyz with |y| > 0, |xy| ≤ p
4. For each split, show ∃i where xy^i z ∉ L
5. Contradiction! Therefore L is not regular.

### 4.2 Pumping Lemma for Context-Free Languages

**Statement:** If L is CFL, then ∃ p such that:
- For all w ∈ L with |w| ≥ p
- w = uvwxy where |vwx| ≤ p and |vx| > 0
- For all i ≥ 0: uv^i wx^i y ∈ L

**Key Difference:** Two strings (v and x) are pumped together

**Use:** Prove language is NON-CFL

**Steps to Prove L Not CFL:**
1. Assume L is CFL with pumping length p
2. Choose w ∈ L with |w| ≥ p
3. Consider all possible splits w = uvwxy satisfying conditions
4. Show ∃i where uv^i wx^i y ∉ L
5. Contradiction! Therefore L is not CFL.

---

## Part 5: Turing Machines

### 5.1 Turing Machine Definition

**Definition:** (Q, Σ, Γ, δ, q0, qaccept, qreject) where:
- Q: Finite set of states
- Σ: Input alphabet
- Γ: Tape alphabet (Σ ⊂ Γ)
- δ: Transition function
- q0: Start state
- qaccept, qreject: Accept and reject states

**Transition:** δ(q, a) = (q', b, L/R)
- Read: a from current tape cell
- Write: b to current cell
- Move: Left (L) or Right (R)
- Go to: q'

### 5.2 Computation by TM

**Accepts:** TM reaches qaccept
**Rejects:** TM reaches qreject
**Loops:** TM never halts

### 5.3 Variants of TM

**Multitape TM:** Multiple tapes, each with independent head
- **Equivalence:** Can simulate with single-tape TM

**Nondeterministic TM:** Multiple possible transitions
- **Equivalence:** Can simulate with deterministic TM

**All variants equivalent in power to single-tape deterministic TM**

### 5.4 Church-Turing Thesis

**Intuitive Thesis:** Algorithm = Computable by TM

**Implications:**
- Anything computable by any model is TM-computable
- TM is the ultimate model of computation

---

## Part 6: Decidability and Undecidability

### 6.1 Decidable Languages

**Definition:** Language L is decidable if ∃ TM M:
- M halts on every input
- M accepts if w ∈ L
- M rejects if w ∉ L

**Examples of Decidable Languages:**
- DFA acceptance: "Does DFA M accept string w?"
- DFA emptiness: "Is language of DFA M empty?"
- CFG membership: "Does CFG generate string w?"
- Regular expression: "Does regex match string w?"

### 6.2 Undecidable Problems

**Definition:** No algorithm (TM) exists to decide for all inputs.

**Famous Examples:**

**Halting Problem:** "Does TM M halt on input w?"
- **Proof:** By contradiction using diagonalization
- Assume decider H exists
- Create machine D that reverses H's answer
- Feed D to itself → Contradiction

**Post Correspondence Problem (PCP):**
- Given two lists of strings
- Find sequence of indices matching concatenation

**Word Problem for Groups:**
- Given group presentation and two words
- Are words equal in group?

**Undecidable but Recognizable:**
- A_TM: "Does TM M accept input w?"
- HALT_TM: "Does TM M halt on input w?"

### 6.3 Recognizable vs Decidable

**Recognizable (RE):** TM accepts if w ∈ L, may not halt if w ∉ L
**Decidable:** TM always halts, accepts or rejects

**Relationship:** Decidable ⊂ Recognizable

**Complement:** If L decidable, L' also decidable
- If L recognizable, L' may not be recognizable

---

## Part 7: Hierarchy of Languages

```
Recursively Enumerable (TM-recognizable)
    ↓
Recursive (Decidable)
    ↓
Context-Free
    ↓
Regular
```

**Properties:**
- Regular ⊂ CFL ⊂ Recursive ⊂ RE
- Undecidable languages in RE but not Recursive

---

## Part 8: Summary of Key Concepts

### Conversions
- Regex ↔ NFA (Thompson's construction)
- NFA ↔ DFA (Subset construction)
- DFA → Regex (Arden's method)
- CFG → PDA (Simulation of derivation)
- PDA → CFG (Reverse construction)

### Proofs of Non-Membership
- Non-regular: Use pumping lemma for regular languages
- Non-CFL: Use pumping lemma for context-free languages
- Undecidable: Use reduction from known undecidable problem

### Decision Properties

| Property | Regular | CFL | Recursive | RE |
|----------|---------|-----|-----------|-----|
| Membership | Decidable | Decidable | Decidable | Recognizable |
| Emptiness | Decidable | Decidable | Decidable | Unrecognizable |
| Finiteness | Decidable | Decidable | Undecidable | Unrecognizable |
| Equivalence | Decidable | Undecidable | Undecidable | Unrecognizable |

---

## High-Weightage Topics for GATE

1. **Regular Expressions & DFA** (12%) - Conversions, constructions
2. **CFG & PDA** (15%) - Parsing, generation, conversion
3. **Pumping Lemmas** (18%) - Proving non-regularity, non-CFL
4. **Turing Machines** (12%) - Definition, variants, computation
5. **Decidability** (18%) - Decidable vs undecidable, examples
6. **Language Hierarchy** (10%) - Relationships, closure properties
7. **Parsing & Recognition** (10%) - Grammar analysis
8. **Other Topics** (5%)

**Focus for GATE:** Pumping lemma, Turing machines, decidability, language conversions
